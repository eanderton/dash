#!/usr/bin/env python

from __future__ import print_function
import os
import subprocess
import yaml
import sys
import tempfile
import argparse


def get_bash_fn_comments(script_lines):
    for line in script_lines:
        if line.startswith('#'):
            yield line.replace('#', '', 1).strip()
        else:
            break
 

def merge_settings(dst, src):
    if 'debug' in src:
        dst['debug'] = src['debug']
    if 'sudo' in src:
        dst['sudo'] = src['sudo']
    dst['functions'].update(src.get('functions', {}))
    dst['scripts'].update(src.get('scripts', {}))
    dst['environment'].update(src.get('environment', {}))


def load_yaml(file_path):
    try:
        with open(file_path) as f:
            return yaml.load(f.read())
    except:
        pass
    return {}


def load_settings(args):
    settings = {
        'functions': {},
        'scripts': {},
        'environment': {},
        'services': {},
        'debug': False,
        'sudo': False,
    }

    merge_settings(settings, load_yaml('/etc/dcsh.yml'))
    if 'HOME' in os.environ:
        merge_settings(settings, load_yaml(os.environ['HOME'] + '/.dcsh.yml'))
    merge_settings(settings, load_yaml('.dcsh.yml'))
    
    dc_config = load_yaml('./docker-compose.yml')
    settings['services'] = dc_config.get('services', {})
    merge_settings(settings, dc_config.get('x-dcsh', {}))

    if args.debug:
        settings['debug'] = True
    if args.sudo:
        settings['sudo'] = True

    return settings


def build_init_script(settings):
    dcsh_cmd = os.path.abspath(sys.argv[0])
    compose_cmd = 'docker-compose'

    # build stock commands
    if settings['debug']:
        dcsh_cmd += ' --debug'
    if settings['sudo']:
        dcsh_cmd += ' --sudo'
        compose_cmd = 'sudo ' + compose_cmd
    init_script = [ 
        'alias reload="source <({} init-script)"'.format(dcsh_cmd),
        'alias help="{} help"'.format(dcsh_cmd),
        'alias dc="{}"'.format(compose_cmd),
        'alias build="dc build"',
        'alias up="dc up"',
        'alias down="dc down"',
    ]
    if settings['debug']:
        init_script = ['set -x'] + init_script + ['set +x']

    # build run aliases from docker compose services
    for service in settings['services'].keys():
        init_script.append('alias {0}="dc run --rm {0}"'.format(service)) 

    # apply optional command functions, scripts, and environment
    for name, script in settings['scripts'].items():
        init_script.append('alias {}="dc {}"'.format(name, script))
    for name, func in settings['functions'].items():
        init_script.append('function {} {{\n{}\n}}'.format(name, func))
    
    return init_script


def launch_subshell(args):
    if os.environ.get('__dcsh__', None):
        print('DCSH already started; use "reload" to refresh environment. Exiting.')
        sys.exit(1) 

    # run bashrc scripts and patch the shell prompt
    settings = load_settings(args)
    if settings['debug']:
        ps1_prefix = '''\e[91m(dcsh debug mode)\e[0m'''
    else:
        ps1_prefix = os.environ.get('DCSH_PS1_PREFIX', '''\e[33m(dcsh)\e[0m''')
    init_script = [
        'if [ -f /etc/bash.bashrc ]; then source /etc/bash.bashrc; fi',
        'if [ -f $HOME/.bashrc ]; then source $HOME/.bashrc; fi',
        'PS1="{}$PS1"'.format(ps1_prefix),
    ] + build_init_script(settings)
   
    # run the subshell
    with tempfile.NamedTemporaryFile() as init_file:
        init_file.write('\n'.join(init_script))
        init_file.flush()
        
        env = dict(os.environ)
        env.update(settings['environment'])
        env['__dcsh__'] = 'true'
        shell = os.environ.get('SHELL', os.environ.get('DCSH_SHELL', '/bin/bash'))
        sh = subprocess.Popen([shell, '--init-file', init_file.name, '-i'], env=env)
        sh.communicate()
        sys.exit(sh.returncode)


def render_init_script(args):
    print('\n'.join(build_init_script(load_settings(args))))


def render_help(args):
    settings = load_settings(args)
    
    if settings['debug']:
        print('Debug mode enabled\n')
    
    if settings['functions']:
        print('Functions:')
        for name, value in settings['functions'].items():
            comment = value.split('\n')
            if not settings['debug']:
                comment = get_bash_fn_comments(value)
            print('  {}: {}'.format(name, '\n    '.join(comment))) 
    else:
        print('No functions are configured.')

    if settings['scripts']:
        print('\nScripts:')
        for name, value in settings['scripts'].items():
            print('  {}: {}'.format(name, value))
    else:
        print('No scripts are configured.')

    if settings['environment']:
        print('\nEnvironment:')
        for name, value in settings['environment'].items():
            print('  {}: {}'.format(name, value))
    else:
        print('No environment are configured.')

    if settings['sudo']:
        print('\nSudo enabled: Calls to docker-compose will use "sudo".') 


def main():
    # set default subcommand for argparse by providing arguments
    if len(sys.argv) == 1:
        sys.argv.append('launch')
    
    # configure parser 
    parser = argparse.ArgumentParser('Shell wrapper for docker-compose')
    parser.add_argument('-s', '--sudo', action='store_true', help='run docker-compose using sudo')
    parser.add_argument('-d', '--debug', action='store_true', help='enable debug output')
    parser.set_defaults(sudo=False, debug=False)
    commands = parser.add_subparsers(title='subcommands')
 
    launch = commands.add_parser('launch', help='launches configured subshell (default)')
    launch.set_defaults(fn=launch_subshell)
 
    init_script = commands.add_parser('init-script', help='outputs the rendered shell init script')
    init_script.set_defaults(fn=render_init_script)

    show_help = commands.add_parser('help', help='shows information about configuration')
    show_help.set_defaults(fn=render_help)

    # run subcommand
    args = parser.parse_args()
    args.fn(args)


if __name__ == '__main__':
    main()
